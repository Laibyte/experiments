---
description: Async/await patterns and best practices
globs: ["**/*.py"]
---

# Python Async/Await

## Async Functions
- Use `async`/`await` for I/O-bound operations
- Use `asyncio.gather()` for concurrent operations
- Use `async with` for async context managers
- Always await coroutines

```python
import asyncio
import httpx
from collections.abc import Sequence

async def fetch_data(url: str) -> dict[str, object]:
    """Fetch data from URL."""
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.json()

async def fetch_all(urls: Sequence[str]) -> list[dict[str, object]]:
    """Fetch data from multiple URLs concurrently."""
    tasks = [fetch_data(url) for url in urls]
    return await asyncio.gather(*tasks)
```

## Error Handling
```python
async def safe_fetch(url: str) -> dict[str, object] | None:
    """Fetch with error handling."""
    try:
        return await fetch_data(url)
    except httpx.HTTPError as e:
        logger.error(f"Failed to fetch {url}: {e}")
        return None
```


## Task Management

```python
# Fire-and-forget
task = asyncio.create_task(background_job())

# Wait with timeout
try:
    result = await asyncio.wait_for(slow_operation(), timeout=5.0)
except asyncio.TimeoutError:
    print("Operation timed out")
```
