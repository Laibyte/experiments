---
description: Testing guidelines and best practices
globs: ["tests/**/*.py"]
---

# Python Testing Standards

## Test Structure
- Test file naming: `test_*.py` or `*_test.py`
- Test function naming: `test_<functionality>`
- Use pytest fixtures for setup/teardown
- Use parametrize for multiple test cases

## Test Organization
```python
import pytest
from my_project.calculator import add, divide

def test_add_positive_numbers() -> None:
    """Test adding positive numbers."""
    assert add(2, 3) == 5

def test_add_negative_numbers() -> None:
    """Test adding negative numbers."""
    assert add(-2, -3) == -5

@pytest.mark.parametrize(
    ("a", "b", "expected"),
    [
        (10, 2, 5),
        (20, 4, 5),
        (100, 10, 10),
    ],
)
def test_divide_parametrized(a: int, b: int, expected: int) -> None:
    """Test division with multiple inputs."""
    assert divide(a, b) == expected

def test_divide_by_zero_raises_error() -> None:
    """Test division by zero raises ValueError."""
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(10, 0)
```

## Coverage Requirements

- Aim for 80%+ code coverage
- Use markers: ⁠@pytest.mark.slow, ⁠@pytest.mark.integration
- Write tests for ALL new functions and classes

## Fixtures

```python
import pytest

@pytest.fixture
def sample_data() -> dict[str, int]:
    """Provide sample data for tests."""
    return {"a": 1, "b": 2}

def test_with_fixture(sample_data: dict[str, int]) -> None:
    """Test using fixture."""
    assert sample_data["a"] == 1
```
